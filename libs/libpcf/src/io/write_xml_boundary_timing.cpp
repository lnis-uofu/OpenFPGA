/********************************************************************
 * This file includes the top-level function of this library
 * which reads an XML of I/O location to the associated
 * data structures
 *******************************************************************/
#include <fstream>
#include <string>

/* Headers from pugi XML library */
#include "pugixml.hpp"
#include "pugixml_util.hpp"

/* Headers from vtr util library */
#include "vtr_assert.h"
#include "vtr_time.h"

/* Headers from libopenfpga util library */

#include "openfpga_port_parser.h"
/* Headers from libarchfpga */
#include "arch_error.h"
#include "command_exit_codes.h"
#include "openfpga_digest.h"
#include "write_xml_boundary_timing.h"

/* Begin namespace openfpga */
namespace openfpga {

/********************************************************************
 * Parse XML codes of a <pin> to an object of BoundaryTiming
 *******************************************************************/
static int write_xml_one_boundary_timing(
  pugi::xml_node& root_node, const BoundaryTiming& boundary_timing,
  const PinConstraintId& pin_constraint) {
  pugi::xml_node tree_node =
    root_node.append_child(XML_BOUNDARY_TIMING_TREE_NODE);
  if (false == boundary_timing.valid_pin_constraint_id(pin_constraint)) {
    return 1;
  }
  auto pin = boundary_timing.pin(pin_constraint);

  tree_node.append_attribute(XML_BOUNDARY_TIMING_TREE_NODE_PIN_NAME) =
    boundary_timing.pin(pin_constraint).to_verilog_string().c_str();

  tree_node.append_attribute(XML_BOUNDARY_TIMING_TREE_NODE_PIN_MIN_DELAY) =
    boundary_timing.pin_min_delay(pin).c_str();

  tree_node.append_attribute(XML_BOUNDARY_TIMING_TREE_NODE_PIN_MAX_DELAY) =
    boundary_timing.pin_max_delay(pin).c_str();

  return CMD_EXEC_SUCCESS;
}

/********************************************************************
 * Parse XML codes about <boundary_timing> to an object of BoundaryTiming
 *******************************************************************/
int write_xml_boundary_timing(const char* fname,
                              const BoundaryTiming& bdy_timing) {
  vtr::ScopedStartFinishTimer timer("Write Boundary Timing File");
  pugi::xml_document out_xml;

  pugi::xml_node root_node =
    out_xml.append_child(XML_BOUNDARY_TIMING_ROOT_NAME);
  root_node.append_child(pugi::node_comment)
    .set_value(
      "This file is automatically generated!!! Do not modify by hand! The "
      "timing scale is ns");

  /* Write region by region */
  for (const PinConstraintId& pin_constraint : bdy_timing.pin_constraints()) {
    /* Write constraint by constraint */
    int status =
      write_xml_one_boundary_timing(root_node, bdy_timing, pin_constraint);
    if (status != CMD_EXEC_SUCCESS) {
      return CMD_EXEC_FATAL_ERROR;
    }
  }
  out_xml.save_file(fname);

  return CMD_EXEC_SUCCESS;
}

} /* End namespace openfpga*/
